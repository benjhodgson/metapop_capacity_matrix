---
title: "Results"
output: 
  html_document: 
    toc: true
    toc_float: true
    keep_md: true
    number_sections: true
date: "2025-04-24"
---
Return to Model README: [README](https://github.com/benjhodgson/metapop_capacity_matrix/blob/main/README.md)

# Exploring Metapopulation Capacity
## The independent effects of habitat cover on metapopulation capacity

Experimental Design: [The independent effects of habitat cover on metapopulation capacity](https://github.com/benjhodgson/metapop_capacity_matrix/blob/main/Documentation/Experimental-Design.md#the-independent-effects-of-habitat-cover-on-metapopulation-capacity)

Changing the size of habitat patches, without changing the distance between the habitat patches gives the following relationship between metapopulation capacity and habitat cover:
```{r area_landscapes_results, echo=FALSE, fig.height=8, message=FALSE, warning=FALSE, dpi=300}


rm(list = ls())

library(tidyverse)
library(patchwork)


# Generate and Plot Habitat Patches ---------------------------------------


# Define 10 equally spaced habitat patches
points_10 <- data.frame(
  x = seq(0, 100, length.out = 10),
  y = seq(0, 100, length.out = 10)
)

# Define 5 equally spaced habitat patches
points_5 <- data.frame(
  x = seq(0, 100, length.out = 5),
  y = seq(0, 100, length.out = 5)
)

# Define 2 equally spaced habitat patches
points_2 <- data.frame(
  x = seq(0, 100, length.out = 2),
  y = seq(0, 100, length.out = 2)
)



# Calculate Metapopulation Capacity ---------------------------------------

# Set alpha
alpha <- 0.05  # change as needed

distance_matrix_2 <- as.matrix(dist(points_2))
distance_matrix_5 <- as.matrix(dist(points_5))
distance_matrix_10 <- as.matrix(dist(points_10))

# Number of patches
n_patches_2 <- nrow(points_2)
n_patches_5 <- nrow(points_5)
n_patches_10 <- nrow(points_10)

# Create results dataframe
results_2 <- data.frame(
  habitat_area = numeric(),
  metapop_cap = numeric()
)
results_5 <- data.frame(
  habitat_area = numeric(),
  metapop_cap = numeric()
)
results_10 <- data.frame(
  habitat_area = numeric(),
  metapop_cap = numeric()
)


# Loop from habitat area 1 to 500 for 2 patches
for (a in 1:500) {
  
  # generate area matrix
  area_matrix <- matrix(a^2, nrow = n_patches_2, ncol = n_patches_2)
  
  dispersal_matrix <- exp(-alpha * distance_matrix_2)
  
  diag(dispersal_matrix) <- 0 # set diagonal back to 0
  
  # multiply dispersal matrix by area matrix
  connectivity_matrix <- area_matrix * dispersal_matrix
  
  # extract eigenvalues
  eig <- eigen(connectivity_matrix)
  
  # find the leading eigenvalue
  leading_eig <- eig$values[1]
  
  # update results
  results_2 <- rbind(results_2, data.frame(habitat_area = a, metapop_cap = leading_eig))
}


# Loop from habitat area 1 to 500 for 5 patches
for (a in 1:500) {
  
  # generate area matrix
  area_matrix <- matrix(a^2, nrow = n_patches_5, ncol = n_patches_5)
  
  dispersal_matrix <- exp(-alpha * distance_matrix_5)
  
  diag(dispersal_matrix) <- 0 # set diagonal back to 0
  
  # multiply dispersal matrix by area matrix
  connectivity_matrix <- area_matrix * dispersal_matrix
  
  # extract eigenvalues
  eig <- eigen(connectivity_matrix)
  
  # find the leading eigenvalue
  leading_eig <- eig$values[1]
  
  # update results
  results_5 <- rbind(results_5, data.frame(habitat_area = a, metapop_cap = leading_eig))
}



# Loop from habitat area 1 to 500 for 10 patches
for (a in 1:500) {
  
  # generate area matrix
  area_matrix <- matrix(a^2, nrow = n_patches_10, ncol = n_patches_10)
  
  
  dispersal_matrix <- exp(-alpha * distance_matrix_10)
  
  diag(dispersal_matrix) <- 0 # set diagonal back to 0
  
  # multiply dispersal matrix by area matrix# Step 3: Connectivity matrix = area * dispersal
  connectivity_matrix <- area_matrix * dispersal_matrix
  
  # extract eigenvalues
  eig <- eigen(connectivity_matrix)
  
  # find the leading eigenvalue
  leading_eig <- eig$values[1]
  
  # update results
  results_10 <- rbind(results_10, data.frame(habitat_area = a, metapop_cap = leading_eig))
}







# Plot Graphs -------------------------------------------------------------

results_2$habitat_cover <- ((results_2$habitat_area * 2)/(100*100)) *100
results_5$habitat_cover <- ((results_5$habitat_area * 5)/(100*100)) *100
results_10$habitat_cover <- ((results_10$habitat_area * 10)/(100*100)) *100


# Plot Metapopulation Capacity

mp_1 <- ggplot(results_2, aes(x = habitat_cover, y = metapop_cap)) +
  geom_line() +
  labs(
    title = "2 Habitat Patches",
    x = "Habitat Cover (%)",
    y = "Metapopulation Capacity"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, face = "plain")
  )

mp_2 <- ggplot(results_5, aes(x = habitat_cover, y = metapop_cap)) +
  geom_line() +
  labs(
    title = "5 Habitat Patches",
    x = "Habitat Cover (%)",
    y = "Metapopulation Capacity"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, face = "plain")
  )

mp_3 <- ggplot(results_10, aes(x = habitat_cover, y = metapop_cap)) +
  geom_line() +
  labs(
    title = "10 Habitat Patches",
    x = "Habitat Cover (%)",
    y = "Metapopulation Capacity"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, face = "plain")
  )
  

mp_1 / mp_2 / mp_3


```

The log of metapopulation capacity plotted against habitat cover gives the following results:

```{r area_landscapes_log_results, echo=FALSE, fig.height=8,  message=FALSE, warning=FALSE, dpi=300}


# Plot log metapopulation capacity

log_mp_1 <- ggplot(results_2, aes(x = habitat_cover, y = log(metapop_cap))) +
  geom_line() +
  labs(
    title = "2 Habitat Patches",
    x = "Habitat Cover (%)",
    y = "Log Metapopulation Capacity"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, face = "plain")
  )

log_mp_2 <- ggplot(results_5, aes(x = habitat_cover, y = log(metapop_cap))) +
  geom_line() +
  labs(
    title = "5 Habitat Patches",
    x = "Habitat Cover (%)",
    y = "Log Metapopulation Capacity"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, face = "plain")
  )

log_mp_3 <- ggplot(results_10, aes(x = habitat_cover, y = log(metapop_cap))) +
  geom_line() +
  labs(
    title = "10 Habitat Patches",
    x = "Habitat Cover (%)",
    y = "Log Metapopulation Capacity"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, face = "plain")
  )


log_mp_1 / log_mp_2 / log_mp_3



```

## The independent effects of inter-patch distance on metapopulation capacity 

Experimental Design: [The independent effects of habitat cover on metapopulation capacity](https://github.com/benjhodgson/metapop_capacity_matrix/blob/main/Documentation/Experimental-Design.md#the-independent-effects-of-inter-patch-distance-on-metapopulation-capacity)

Scaling the dispersal matrix whilst keeping the habitat area constant gives the following relationship between metapopulation capacity and mean distance between habitat patches.
```{r dispersal_landscapes_results, echo=FALSE, fig.height=8, message=FALSE, warning=FALSE, dpi=300}



rm(list = ls())

library(tidyverse)
library(patchwork)


# Generate and Plot Habitat Patches ---------------------------------------


# Define 10 equally spaced habitat patches
points_10 <- data.frame(
  x = seq(0, 100, length.out = 10),
  y = seq(0, 100, length.out = 10)
)

# Define 5 equally spaced habitat patches
points_5 <- data.frame(
  x = seq(0, 100, length.out = 5),
  y = seq(0, 100, length.out = 5)
)

# Define 2 equally spaced habitat patches
points_2 <- data.frame(
  x = seq(0, 100, length.out = 2),
  y = seq(0, 100, length.out = 2)
)



# Calculate Metapopulation Capacity ---------------------------------------

# Set alpha
alpha <- 0.05  

# Number of patches
n_patches_2 <- nrow(points_2)
n_patches_5 <- nrow(points_5)
n_patches_10 <- nrow(points_10)

distance_matrix_2 <- as.matrix(dist(points_2))
distance_matrix_5 <- as.matrix(dist(points_5))
distance_matrix_10 <- as.matrix(dist(points_10))

# Create results dataframe
results_2 <- data.frame(
  mean_distance = numeric(),
  metapop_cap = numeric()
)
results_5 <- data.frame(
  mean_distance = numeric(),
  metapop_cap = numeric()
)
results_10 <- data.frame(
  mean_distance = numeric(),
  metapop_cap = numeric()
)

# set area to 100 units
a <- 100

# Loop from distance multiplier of 1 to 500
for (d in seq(1, 5, by = 0.01)) {
  
  # generate area matrix
  area_matrix <- matrix(a^2, nrow = n_patches_2, ncol = n_patches_2)
  
  scaled_distance_matrix <- distance_matrix_2 *d
  
  dispersal_matrix <- exp(-alpha * scaled_distance_matrix)
  
  diag(dispersal_matrix) <- 0 # set diagonal back to 0
  
  # multiply dispersal matrix by area matrix
  connectivity_matrix <- area_matrix * dispersal_matrix
  
  # extract eigenvalues
  eig <- eigen(connectivity_matrix)
  
  # find the leading eigenvalue
  leading_eig <- eig$values[1]
  
  # calculate mean distance
  dist_vector <- scaled_distance_matrix[lower.tri(scaled_distance_matrix)]
  mean_distance <- mean(dist_vector)
  
  # update results
  results_2 <- rbind(results_2, data.frame(mean_distance = mean_distance, metapop_cap = leading_eig))
}


# Loop from distance multiplier of 1 to 500
for (d in seq(1, 5, by = 0.01)) {
  
  # generate area matrix
  area_matrix <- matrix(a^2, nrow = n_patches_5, ncol = n_patches_5)
  
  distance_matrix <- distance_matrix_5 *d
  
  dispersal_matrix <- exp(-alpha * distance_matrix)
  
  diag(dispersal_matrix) <- 0 # set diagonal back to 0
  
  # multiply dispersal matrix by area matrix
  connectivity_matrix <- area_matrix * dispersal_matrix
  
  # extract eigenvalues
  eig <- eigen(connectivity_matrix)
  
  # find the leading eigenvalue
  leading_eig <- eig$values[1]
  
  # calculate mean distance
  dist_vector <- distance_matrix[lower.tri(distance_matrix)]
  mean_distance <- mean(dist_vector)
  
  # update results
  results_5 <- rbind(results_5, data.frame(mean_distance = mean_distance, metapop_cap = leading_eig))
}




# Loop from distance multiplier of 1 to 500
for (d in seq(1, 5, by = 0.01)) {
  
  # generate area matrix
  area_matrix <- matrix(a^2, nrow = n_patches_10, ncol = n_patches_10)
  
  distance_matrix <- distance_matrix_10 *d
  
  dispersal_matrix <- exp(-alpha * distance_matrix)
  
  # multiply dispersal matrix by area matrix
  connectivity_matrix <- area_matrix * dispersal_matrix
  
  # extract eigenvalues
  eig <- eigen(connectivity_matrix)
  
  # find the leading eigenvalue
  leading_eig <- eig$values[1]
  
  # calculate mean distance
  dist_vector <- distance_matrix[lower.tri(distance_matrix)]
  mean_distance <- mean(dist_vector)
  
  # update results
  results_10 <- rbind(results_10, data.frame(mean_distance = mean_distance, metapop_cap = leading_eig))
}







# Plot Graphs -------------------------------------------------------------


# Plot Metapopulation Capacity

mp_1 <- ggplot(results_2, aes(x = mean_distance, y = metapop_cap)) +
  geom_line() +
  labs(
    title = "2 Habitat Patches",
    x = "Mean Distance between Patches",
    y = "Metapopulation Capacity"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, face = "plain")
  )

mp_2 <- ggplot(results_5, aes(x = mean_distance, y = metapop_cap)) +
  geom_line() +
  labs(
    title = "5 Habitat Patches",
    x = "Mean Distance between Patches",
    y = "Metapopulation Capacity"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, face = "plain")
  )

mp_3 <- ggplot(results_10, aes(x = mean_distance, y = metapop_cap)) +
  geom_line() +
  labs(
    title = "10 Habitat Patches",
    x = "Mean Distance between Patches",
    y = "Metapopulation Capacity"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, face = "plain")
  )


mp_1 / mp_2 / mp_3

```


The log of metapopulation capacity plotted against mean distance between patches gives the following results:

```{r distance_landscapes_log_results, echo=FALSE, fig.height=8, message=FALSE, warning=FALSE, dpi=300}

# Plot log metapopulation capacity

log_mp_1 <- ggplot(results_2, aes(x = mean_distance, y = log(metapop_cap))) +
  geom_line() +
  labs(
    title = "2 Habitat Patches",
    x = "Mean Distance between Patches",
    y = "Log Metapopulation Capacity"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, face = "plain")
  )

log_mp_2 <- ggplot(results_5, aes(x = mean_distance, y = log(metapop_cap))) +
  geom_line() +
  labs(
    title = "5 Habitat Patches",
    x = "Mean Distance between Patches",
    y = "Log Metapopulation Capacity"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, face = "plain")
  )

log_mp_3 <- ggplot(results_10, aes(x = mean_distance, y = log(metapop_cap))) +
  geom_line() +
  labs(
    title = "10 Habitat Patches",
    x = "Mean Distance between Patches",
    y = "Log Metapopulation Capacity"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 10, face = "plain")
  )


log_mp_1 / log_mp_2 / log_mp_3



```

## The effects of habitat configuration on patch distances and areas

Experimental Design: [The effects of habitat configuration on patch distances and areas](https://github.com/benjhodgson/metapop_capacity_matrix/blob/main/Documentation/Experimental-Design.md#the-effects-of-habitat-configuration-on-patch-distances-and-areas)

```{r config_distance_results, echo=FALSE, message=FALSE, warning=FALSE, dpi=300}

rm(list = ls())

library(tidyverse)
library(cowplot)
library(patchwork)

df <- read.csv("Results_Folder/Exploring Metapopulation Capacity/Configuration Distance Relationship/config_dist_summary.csv")

p1 <- ggplot(df, aes(x = as.factor(p), y = edge_density)) +
  geom_boxplot() +
  labs(x = "p", y = "Edge Density") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme_cowplot()

p2 <- ggplot(df, aes(x = as.factor(p), y = mean_distance )) +
  geom_boxplot() +
  labs(x = "p", y = "Mean inter-patch Distance") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme_cowplot()

p3 <- ggplot(df, aes(x = as.factor(p), y = mean_nearest_distance )) +
  geom_boxplot() +
  labs(x = "p", y = "Mean nearest-neighbour Distance") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme_cowplot()

p4 <- ggplot(df, aes(x = as.factor(p), y = num_patches )) +
  geom_boxplot() +
  labs(x = "p", y = "Number of Patches") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme_cowplot()

p5 <- ggplot(df, aes(x = as.factor(p), y = mean_patch_area )) +
  geom_boxplot() +
  labs(x = "p", y = "Mean Habitat Patch Area") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme_cowplot()

p1 + p2 + p3 + p4 + p5


```


