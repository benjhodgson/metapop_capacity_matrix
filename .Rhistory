# Identify connected patches
clumps <- clump(landscape, directions = 8)
# Calculate edge density
edge_density <- as.numeric(
lsm_l_ed(landscape, count_boundary = FALSE, directions = 8)[6]
)
# Convert raster to data frame
landscape_df <- rasterToPoints(landscape, spatial = TRUE) %>%
as.data.frame()
colnames(landscape_df) <- c("layer", "x", "y")
landscape_df$layer <- as.factor(landscape_df$layer)
# Add clump IDs (patches)
coordinates(landscape_df) <- ~x + y
landscape_df$patch <- terra::extract(clumps, landscape_df)
landscape_df <- as.data.frame(landscape_df)
# Calculate patch data
num_patches <- length(unique(landscape_df$patch))-1
mean_patch_area <- (sum(landscape_df$layer == 1))/num_patches
# Create patch raster
patch_raster <- rasterFromXYZ(landscape_df[, c("x", "y", "patch")])
res(patch_raster) <- c(1, 1)
crs(patch_raster) <- CRS("+proj=utm +zone=33 +datum=WGS84")
# Convert raster to polygons and compute distance matrix
habitat_polygons <- rasterToPolygons(patch_raster, fun = function(x) {x > 0}, dissolve = TRUE)
habitat_polygons_sf <- st_as_sf(habitat_polygons)
dist_matrix <- st_distance(habitat_polygons_sf)
# Inter-patch distances
dist_vector <- as.numeric(dist_matrix[lower.tri(dist_matrix)])
mean_distance <- mean(dist_vector)
# Store results
landscape_list[[config_name]][[replicate]] <- landscape_df
distance_matrices[[config_name]][[replicate]] <- dist_vector
# Add to summary data frame
summary_data <- rbind(summary_data, data.frame(
p = landscape_config,
replicate = replicate,
edge_density = edge_density,
mean_distance = mean_distance,
num_patches = num_patches,
mean_patch_area = mean_patch_area
))
# Progress message
cat("Finished config:", landscape_config, "replicate:", replicate, "\n")
}
}
# unwrap list to get a data frame
landscape_df_final <- bind_rows(
lapply(names(landscape_list), function(config_name) {
# Combine the replicates into a single data frame
df <- bind_rows(landscape_list[[config_name]], .id = "replicate")
# Extract the numeric config value from the name "config_0.1", etc.
config_val <- as.numeric(str_remove(config_name, "config_"))
# Add config value as a new column
df$landscape_config <- config_val
return(df)
}),
.id = "config_id"
)
View(summary_data)
str(dist_matrix)
str(dist_vector)
# nearest-neighbour distances
diag(dist_vals) <- NA # set diagonal to NAs
# nearest-neighbour distances
diag(dist_matrix) <- NA # set diagonal to NAs
# Find the nearest neighbor distance for each patch
nearest_neighbors <- apply(dist_vals, 1, min, na.rm = TRUE)
# nearest-neighbour distances
diag(dist_matrix) <- NA # set diagonal to NAs
# Find the nearest neighbor distance for each patch
nearest_neighbors <- apply(dist_matrix, 1, min, na.rm = TRUE)
# Mean nearest neighbor distance
mean_nearest_distance <- mean(nearest_neighbors, na.rm = TRUE)
dist_matrix
view(dist_matrix)
rm(list = ls())
set.seed(123)
# set resolution and extent
resolution <- 1 # set resolution
# set habitat configuration and covers
landscape_config_vector <- c(0.01, 0.1, 0.2, 0.4) # level of patch aggregation
x_extent <- 100 # set width
y_extent <- 100 # set height
# set habitat configuration and covers
landscape_config_vector <- c(0.01, 0.1, 0.2, 0.4) # level of patch aggregation
ai <- 0.15 #  random proportion of landscape that is habitat between species bounds
# Set up list to store everything
landscape_list <- list()
distance_matrices <- list()
summary_data <- data.frame()
# Loop through each config
for (landscape_config in landscape_config_vector) {
config_name <- paste0("config_", landscape_config)
landscape_list[[config_name]] <- list()
distance_matrices[[config_name]] <- list()
for (replicate in 1:2) {  # Change to 100 when you're ready
# Generate landscape
landscape <- nlm_randomcluster(
ncol = x_extent, nrow = y_extent,
resolution = resolution,
p = landscape_config,
ai = c((1 - ai), ai)
)
# Identify connected patches
clumps <- clump(landscape, directions = 8)
# Calculate edge density
edge_density <- as.numeric(
lsm_l_ed(landscape, count_boundary = FALSE, directions = 8)[6]
)
# Convert raster to data frame
landscape_df <- rasterToPoints(landscape, spatial = TRUE) %>%
as.data.frame()
colnames(landscape_df) <- c("layer", "x", "y")
landscape_df$layer <- as.factor(landscape_df$layer)
# Add clump IDs (patches)
coordinates(landscape_df) <- ~x + y
landscape_df$patch <- terra::extract(clumps, landscape_df)
landscape_df <- as.data.frame(landscape_df)
# Calculate patch data
num_patches <- length(unique(landscape_df$patch))-1
mean_patch_area <- (sum(landscape_df$layer == 1))/num_patches
# Create patch raster
patch_raster <- rasterFromXYZ(landscape_df[, c("x", "y", "patch")])
res(patch_raster) <- c(1, 1)
crs(patch_raster) <- CRS("+proj=utm +zone=33 +datum=WGS84")
# Convert raster to polygons and compute distance matrix
habitat_polygons <- rasterToPolygons(patch_raster, fun = function(x) {x > 0}, dissolve = TRUE)
habitat_polygons_sf <- st_as_sf(habitat_polygons)
dist_matrix <- st_distance(habitat_polygons_sf)
# Inter-patch distances
dist_vector <- as.numeric(dist_matrix[lower.tri(dist_matrix)])
mean_distance <- mean(dist_vector)
# nearest-neighbour distances
diag(dist_matrix) <- NA # set diagonal to NAs
# Find the nearest neighbor distance for each patch
nearest_neighbors <- apply(dist_matrix, 1, min, na.rm = TRUE)
# Mean nearest neighbor distance
mean_nearest_distance <- mean(nearest_neighbors, na.rm = TRUE)
# Store results
landscape_list[[config_name]][[replicate]] <- landscape_df
distance_matrices[[config_name]][[replicate]] <- dist_vector
# Add to summary data frame
summary_data <- rbind(summary_data, data.frame(
p = landscape_config,
replicate = replicate,
edge_density = edge_density,
mean_distance = mean_distance,
mean_nearest_distance = mean_nearest_distance,
num_patches = num_patches,
mean_patch_area = mean_patch_area
))
# Progress message
cat("Finished config:", landscape_config, "replicate:", replicate, "\n")
}
}
# unwrap list to get a data frame
landscape_df_final <- bind_rows(
lapply(names(landscape_list), function(config_name) {
# Combine the replicates into a single data frame
df <- bind_rows(landscape_list[[config_name]], .id = "replicate")
# Extract the numeric config value from the name "config_0.1", etc.
config_val <- as.numeric(str_remove(config_name, "config_"))
# Add config value as a new column
df$landscape_config <- config_val
return(df)
}),
.id = "config_id"
)
View(summary_data)
getwd()
write.csv(summary_data, "C:/Users/bs20brkh/OneDrive - University of Leeds/PhD/Topic 1/metapop_capacity_matrix/Results/Results_Folder/Exploring Metapopulation Capacity/Configuration Distance Relationship/config_dist_summary.csv")
# Effect of landscape configuration on distance ---------------------------
rm(list = ls())
set.seed(123)
# set resolution and extent
resolution <- 1 # set resolution
# set habitat configuration and covers
landscape_config_vector <- c(0.01, 0.1, 0.2, 0.4) # level of patch aggregation
x_extent <- 100 # set width
y_extent <- 100 # set height
# set habitat configuration and covers
landscape_config_vector <- c(0.01, 0.1, 0.2, 0.4) # level of patch aggregation
ai <- 0.15 #  random proportion of landscape that is habitat between species bounds
# Set up list to store everything
landscape_list <- list()
distance_matrices <- list()
summary_data <- data.frame()
# Loop through each config
for (landscape_config in landscape_config_vector) {
config_name <- paste0("config_", landscape_config)
landscape_list[[config_name]] <- list()
distance_matrices[[config_name]] <- list()
for (replicate in 1:25) {  # Change to 100 when you're ready
# Generate landscape
landscape <- nlm_randomcluster(
ncol = x_extent, nrow = y_extent,
resolution = resolution,
p = landscape_config,
ai = c((1 - ai), ai)
)
# Identify connected patches
clumps <- clump(landscape, directions = 8)
# Calculate edge density
edge_density <- as.numeric(
lsm_l_ed(landscape, count_boundary = FALSE, directions = 8)[6]
)
# Convert raster to data frame
landscape_df <- rasterToPoints(landscape, spatial = TRUE) %>%
as.data.frame()
colnames(landscape_df) <- c("layer", "x", "y")
landscape_df$layer <- as.factor(landscape_df$layer)
# Add clump IDs (patches)
coordinates(landscape_df) <- ~x + y
landscape_df$patch <- terra::extract(clumps, landscape_df)
landscape_df <- as.data.frame(landscape_df)
# Calculate patch data
num_patches <- length(unique(landscape_df$patch))-1
mean_patch_area <- (sum(landscape_df$layer == 1))/num_patches
# Create patch raster
patch_raster <- rasterFromXYZ(landscape_df[, c("x", "y", "patch")])
res(patch_raster) <- c(1, 1)
crs(patch_raster) <- CRS("+proj=utm +zone=33 +datum=WGS84")
# Convert raster to polygons and compute distance matrix
habitat_polygons <- rasterToPolygons(patch_raster, fun = function(x) {x > 0}, dissolve = TRUE)
habitat_polygons_sf <- st_as_sf(habitat_polygons)
dist_matrix <- st_distance(habitat_polygons_sf)
# Inter-patch distances
dist_vector <- as.numeric(dist_matrix[lower.tri(dist_matrix)])
mean_distance <- mean(dist_vector)
# nearest-neighbour distances
diag(dist_matrix) <- NA # set diagonal to NAs
# Find the nearest neighbor distance for each patch
nearest_neighbors <- apply(dist_matrix, 1, min, na.rm = TRUE)
# Mean nearest neighbor distance
mean_nearest_distance <- mean(nearest_neighbors, na.rm = TRUE)
# Store results
landscape_list[[config_name]][[replicate]] <- landscape_df
distance_matrices[[config_name]][[replicate]] <- dist_vector
# Add to summary data frame
summary_data <- rbind(summary_data, data.frame(
p = landscape_config,
replicate = replicate,
edge_density = edge_density,
mean_distance = mean_distance,
mean_nearest_distance = mean_nearest_distance,
num_patches = num_patches,
mean_patch_area = mean_patch_area
))
# Progress message
cat("Finished config:", landscape_config, "replicate:", replicate, "\n")
}
}
library(parallel)
rm(list = ls())
set.seed(123)
# set resolution and extent
resolution <- 1 # set resolution
# set habitat configuration and covers
landscape_config_vector <- c(0.01, 0.1, 0.2, 0.4) # level of patch aggregation
x_extent <- 100 # set width
y_extent <- 100 # set height
# set habitat configuration and covers
landscape_config_vector <- c(0.01, 0.1, 0.2, 0.4) # level of patch aggregation
ai <- 0.15 #  random proportion of landscape that is habitat between species bounds
n_replicates <- 25 # set the number of replicates
# Set up list to store everything
landscape_list <- list()
distance_matrices <- list()
summary_data <- data.frame()
# Simulation function for a single replicate
simulate_replicate <- function(replicate, landscape_config, resolution, x_extent, y_extent, ai) {
landscape <- nlm_randomcluster(
ncol = x_extent, nrow = y_extent,
resolution = resolution,
p = landscape_config,
ai = c((1 - ai), ai)
)
clumps <- clump(landscape, directions = 8)
edge_density <- as.numeric(
lsm_l_ed(landscape, count_boundary = FALSE, directions = 8)[6]
)
landscape_df <- rasterToPoints(landscape, spatial = TRUE) %>%
as.data.frame()
colnames(landscape_df) <- c("layer", "x", "y")
landscape_df$layer <- as.factor(landscape_df$layer)
coordinates(landscape_df) <- ~x + y
landscape_df$patch <- terra::extract(clumps, landscape_df)[,1]
landscape_df <- as.data.frame(landscape_df)
num_patches <- length(unique(landscape_df$patch)) - 1
mean_patch_area <- (sum(landscape_df$layer == 1)) / num_patches
patch_raster <- rasterFromXYZ(landscape_df[, c("x", "y", "patch")])
res(patch_raster) <- c(1, 1)
crs(patch_raster) <- CRS("+proj=utm +zone=33 +datum=WGS84")
habitat_polygons <- rasterToPolygons(patch_raster, fun = function(x) {x > 0}, dissolve = TRUE)
habitat_polygons_sf <- st_as_sf(habitat_polygons)
dist_matrix <- st_distance(habitat_polygons_sf)
dist_vector <- as.numeric(dist_matrix[lower.tri(dist_matrix)])
mean_distance <- mean(dist_vector, na.rm = TRUE)
diag(dist_matrix) <- NA
nearest_neighbors <- apply(dist_matrix, 1, min, na.rm = TRUE)
mean_nearest_distance <- mean(nearest_neighbors, na.rm = TRUE)
list(
replicate = replicate,
landscape_df = landscape_df,
dist_vector = dist_vector,
summary = data.frame(
p = landscape_config,
replicate = replicate,
edge_density = edge_density,
mean_distance = mean_distance,
mean_nearest_distance = mean_nearest_distance,
num_patches = num_patches,
mean_patch_area = mean_patch_area
)
)
}
# Loop through each config and simulate in parallel
for (landscape_config in landscape_config_vector) {
config_name <- paste0("config_", landscape_config)
results <- mclapply(
1:n_replicates,
simulate_replicate,
landscape_config = landscape_config,
resolution = resolution,
x_extent = x_extent,
y_extent = y_extent,
ai = ai,
mc.cores = 1
)
landscape_list[[config_name]] <- lapply(results, function(x) x$landscape_df)
distance_matrices[[config_name]] <- lapply(results, function(x) x$dist_vector)
summary_data <- rbind(summary_data, do.call(rbind, lapply(results, function(x) x$summary)))
cat("Finished config:", landscape_config, "\n")
}
rm(list = ls())
set.seed(123)
# set resolution and extent
resolution <- 1 # set resolution
# set habitat configuration and covers
landscape_config_vector <- c(0.01, 0.1, 0.2, 0.4) # level of patch aggregation
x_extent <- 100 # set width
y_extent <- 100 # set height
# set habitat configuration and covers
landscape_config_vector <- c(0.01, 0.1, 0.2, 0.4) # level of patch aggregation
ai <- 0.15 #  random proportion of landscape that is habitat between species bounds
n_replicates <- 2 # set the number of replicates
# Set up list to store everything
landscape_list <- list()
distance_matrices <- list()
summary_data <- data.frame()
# Simulation function for a single replicate
simulate_replicate <- function(replicate, landscape_config, resolution, x_extent, y_extent, ai) {
landscape <- nlm_randomcluster(
ncol = x_extent, nrow = y_extent,
resolution = resolution,
p = landscape_config,
ai = c((1 - ai), ai)
)
clumps <- clump(landscape, directions = 8)
edge_density <- as.numeric(
lsm_l_ed(landscape, count_boundary = FALSE, directions = 8)[6]
)
landscape_df <- rasterToPoints(landscape, spatial = TRUE) %>%
as.data.frame()
colnames(landscape_df) <- c("layer", "x", "y")
landscape_df$layer <- as.factor(landscape_df$layer)
coordinates(landscape_df) <- ~x + y
landscape_df$patch <- terra::extract(clumps, landscape_df)[,1]
landscape_df <- as.data.frame(landscape_df)
num_patches <- length(unique(landscape_df$patch)) - 1
mean_patch_area <- (sum(landscape_df$layer == 1)) / num_patches
patch_raster <- rasterFromXYZ(landscape_df[, c("x", "y", "patch")])
res(patch_raster) <- c(1, 1)
crs(patch_raster) <- CRS("+proj=utm +zone=33 +datum=WGS84")
habitat_polygons <- rasterToPolygons(patch_raster, fun = function(x) {x > 0}, dissolve = TRUE)
habitat_polygons_sf <- st_as_sf(habitat_polygons)
dist_matrix <- st_distance(habitat_polygons_sf)
dist_vector <- as.numeric(dist_matrix[lower.tri(dist_matrix)])
mean_distance <- mean(dist_vector, na.rm = TRUE)
diag(dist_matrix) <- NA
nearest_neighbors <- apply(dist_matrix, 1, min, na.rm = TRUE)
mean_nearest_distance <- mean(nearest_neighbors, na.rm = TRUE)
list(
replicate = replicate,
landscape_df = landscape_df,
dist_vector = dist_vector,
summary = data.frame(
p = landscape_config,
replicate = replicate,
edge_density = edge_density,
mean_distance = mean_distance,
mean_nearest_distance = mean_nearest_distance,
num_patches = num_patches,
mean_patch_area = mean_patch_area
)
)
}
# Loop through each config and simulate in parallel
for (landscape_config in landscape_config_vector) {
config_name <- paste0("config_", landscape_config)
results <- mclapply(
1:n_replicates,
simulate_replicate,
landscape_config = landscape_config,
resolution = resolution,
x_extent = x_extent,
y_extent = y_extent,
ai = ai,
mc.cores = 1
)
landscape_list[[config_name]] <- lapply(results, function(x) x$landscape_df)
distance_matrices[[config_name]] <- lapply(results, function(x) x$dist_vector)
summary_data <- rbind(summary_data, do.call(rbind, lapply(results, function(x) x$summary)))
cat("Finished config:", landscape_config, "\n")
}
rm(list = ls())
set.seed(123)
# set resolution and extent
resolution <- 1 # set resolution
# set habitat configuration and covers
landscape_config_vector <- c(0.01, 0.1, 0.2, 0.4) # level of patch aggregation
x_extent <- 100 # set width
y_extent <- 100 # set height
# set habitat configuration and covers
landscape_config_vector <- c(0.01, 0.1, 0.2, 0.4) # level of patch aggregation
ai <- 0.15 #  random proportion of landscape that is habitat between species bounds
n_replicates <- 2 # set the number of replicates
# Set up list to store everything
landscape_list <- list()
distance_matrices <- list()
summary_data <- data.frame()
# Simulation function for a single replicate
simulate_replicate <- function(replicate, landscape_config, resolution, x_extent, y_extent, ai) {
landscape <- nlm_randomcluster(
ncol = x_extent, nrow = y_extent,
resolution = resolution,
p = landscape_config,
ai = c((1 - ai), ai)
)
clumps <- clump(landscape, directions = 8)
edge_density <- as.numeric(
lsm_l_ed(landscape, count_boundary = FALSE, directions = 8)[6]
)
landscape_df <- rasterToPoints(landscape, spatial = TRUE) %>%
as.data.frame()
colnames(landscape_df) <- c("layer", "x", "y")
landscape_df$layer <- as.factor(landscape_df$layer)
coordinates(landscape_df) <- ~x + y
landscape_df$patch <- terra::extract(clumps, landscape_df)
landscape_df <- as.data.frame(landscape_df)
num_patches <- length(unique(landscape_df$patch)) - 1
mean_patch_area <- (sum(landscape_df$layer == 1)) / num_patches
patch_raster <- rasterFromXYZ(landscape_df[, c("x", "y", "patch")])
res(patch_raster) <- c(1, 1)
crs(patch_raster) <- CRS("+proj=utm +zone=33 +datum=WGS84")
habitat_polygons <- rasterToPolygons(patch_raster, fun = function(x) {x > 0}, dissolve = TRUE)
habitat_polygons_sf <- st_as_sf(habitat_polygons)
dist_matrix <- st_distance(habitat_polygons_sf)
dist_vector <- as.numeric(dist_matrix[lower.tri(dist_matrix)])
mean_distance <- mean(dist_vector, na.rm = TRUE)
diag(dist_matrix) <- NA
nearest_neighbors <- apply(dist_matrix, 1, min, na.rm = TRUE)
mean_nearest_distance <- mean(nearest_neighbors, na.rm = TRUE)
list(
replicate = replicate,
landscape_df = landscape_df,
dist_vector = dist_vector,
summary = data.frame(
p = landscape_config,
replicate = replicate,
edge_density = edge_density,
mean_distance = mean_distance,
mean_nearest_distance = mean_nearest_distance,
num_patches = num_patches,
mean_patch_area = mean_patch_area
)
)
}
# Loop through each config and simulate in parallel
for (landscape_config in landscape_config_vector) {
config_name <- paste0("config_", landscape_config)
results <- mclapply(
1:n_replicates,
simulate_replicate,
landscape_config = landscape_config,
resolution = resolution,
x_extent = x_extent,
y_extent = y_extent,
ai = ai,
mc.cores = 1
)
landscape_list[[config_name]] <- lapply(results, function(x) x$landscape_df)
distance_matrices[[config_name]] <- lapply(results, function(x) x$dist_vector)
summary_data <- rbind(summary_data, do.call(rbind, lapply(results, function(x) x$summary)))
cat("Finished config:", landscape_config, "\n")
}
# Combine all landscape data frames
landscape_df_final <- bind_rows(
lapply(names(landscape_list), function(config_name) {
df <- bind_rows(landscape_list[[config_name]], .id = "replicate")
config_val <- as.numeric(str_remove(config_name, "config_"))
df$landscape_config <- config_val
return(df)
}),
.id = "config_id"
)
View(summary_data)
write.csv(summary_data, "/Results/Results_Folder/Exploring Metapopulation Capacity/Configuration Distance Relationship/config_dist_summary.csv")
write.csv(landscape_df_final, "/Results/Results_Folder/Exploring Metapopulation Capacity/Configuration Distance Relationship/config_dist_landscapes.csv")
write.csv(summary_data, "Results/Results_Folder/Exploring Metapopulation Capacity/Configuration Distance Relationship/config_dist_summary.csv")
write.csv(landscape_df_final, "Results/Results_Folder/Exploring Metapopulation Capacity/Configuration Distance Relationship/config_dist_landscapes.csv")
getwd()
