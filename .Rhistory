install.packages("devtools")
library(devtools)
install.packages(c("tidyverse", "parallel", "dplyr", "sf", "units", "ggplot2", "gganimate"))
install.packages("igraph")
install.packages("raster")
install.packages("landscapemetrics")
devtools::install_github("ropensci/NLMR")
install.packages('RandomFields', repos =
'https://predictiveecology.r-universe.dev', type = 'source')
library(tidyverse)
library(parallel)
library(NLMR)
library(RandomFields)
library(landscapemetrics)
library(igraph)
library(raster)
library(dplyr)
library(sf)
library(units)
library(ggplot2)
# Start timer
start_timer <- Sys.time()
# Loop for dispersal scenarios --------------------------------------------
# Set landscape productivity target
productivity <- 0.5
# Define movement responses
# movement can be 'linear', 'convex', or 'concave'
movements <- c('linear', 'concave', 'convex')
# Define maximum movement increases (%)
movement_abilities <- c(50, 100, 500, 1000)
# Create grid of movement combinations
movement_combos <- expand.grid(movement = movements, movement_ability = movement_abilities)
# Create a new row for null movement
new_row <- data.frame(movement = "none", movement_ability = 0)
# Add the new row to the grid
movement_combos <- rbind(movement_combos, new_row)
rm(new_row)
# set movement as a character
movement_combos$movement <- as.character(movement_combos$movement)
# Create df of slope constants
m <- c("linear", "linear", "linear", "linear", "concave", "concave", "concave", "concave", "convex", "convex", "convex", "convex")
m_a <- c("50", "100", "500", "1000", "50", "100", "500", "1000", "50", "100", "500", "1000")
s1 <- c(0.5, 1, 5, 10, 0.5, 1, 5, 10, 2.27e-5, 4.54e-5, 2.27e-4, 4.53e-4)
s2 <- c(NA, NA, NA, NA, NA, NA, NA, NA, 0, 0, 0, 0)
a <- c(1, 1, 1, 1, 0.5, 1, 5, 10, 1, 1, 1, 1)
slopes <- data.frame(m, m_a, s1, s2, a)
# create final dataset list
result_final_complete <- list()
for (j in 1:nrow(movement_combos)) {
movement <- movement_combos$movement[j]
movement_ability <- movement_combos$movement_ability[j]
# Create Empty Dataframes -------------------------------------------------
# Create metapopulation dynamics results data frame and final dataframe
results <- data.frame()
# Create landscape final dataframe
landscape_final <- data.frame(
# rep = numeric(),
layer = numeric(),
x = numeric(),
y = numeric(),
patch = numeric())
# Create parameter final dataframe
params_final <- data.frame(
# rep = numeric(),
alpha = numeric(),
x = numeric(),
y = numeric(),
e = numeric(),
start_p = numeric(),
resolution = numeric(),
x_extent = numeric(),
y_extent = numeric(),
landscape_config = numeric(),
landscape_cover = numeric(),
edge_density = numeric(),
mean_distance = numeric(),
mean_patch_size = numeric())
# create parameters for function
param_movement <- list(
movement = movement,
movement_ability = movement_ability
)
# Simulation Function -----------------------------------------------------
rep_function <- function(movement, movement_ability) {
# Set Landscape Parameters ------------------------------------------------
resolution <- 1 # set resolution
x_extent <- 50 # set width
y_extent <- 50 # set height
landscape_config <- 0.4 # level of patch aggregation
ai <- runif(1, min = 0.01, max = 0.45) # proportion of landscape that is habitat
# Generate Landscape ------------------------------------------------------
## Habitat Patches ========================================================
# create neutral landscape with >1 patch
repeat {
# generate landscape using NLMR package
landscape <- nlm_randomcluster(ncol = x_extent, nrow = y_extent,
resolution = resolution,
p = landscape_config,
ai = c((1-ai),ai))
# identify connected patches
clumps <- clump(landscape, directions = 8)
# calculate edge_density
edge_density <- as.numeric(lsm_l_ed(landscape, count_boundary = FALSE, directions = 8)[6])
# coerce to data frame
landscape_df <- rasterToPoints(landscape, spatial = TRUE)
landscape_df <- as.data.frame(landscape_df)
colnames(landscape_df) <- c("layer", "x", "y")
landscape_df$layer <- as.factor(landscape_df$layer)
# add patch numbers to landscape df
coordinates(landscape_df) <- ~x + y
landscape_df$patch <- extract(clumps, landscape_df)
landscape_df <- as.data.frame(landscape_df)
# Check the maximum patch number
max_patch_number <- max(landscape_df$patch, na.rm = TRUE)
# If there is more than one patch, exit the loop
if (max_patch_number > 1) {
break
}
}
# calculate exact landscape cover
landscape_cover <- (sum(landscape_df$layer == 1)/nrow(landscape_df))*100
# remove unecessary variables
rm(clumps)
rm(landscape)
## Calculate Distances and Areas ==========================================
# Calculate distances
# dataframe back to raster
landscape_df_patches <- landscape_df %>%
dplyr::select(x, y, patch)
patch_raster <- rasterFromXYZ(landscape_df_patches)
# remove unnecessary variables
rm(landscape_df_patches)
# set resolution of raster
res(patch_raster) <- c(1, 1)
# set crs of raster
crs(patch_raster) <- CRS("+proj=utm +zone=33 +datum=WGS84")
# Convert raster to polygons
habitat_polygons <- rasterToPolygons(patch_raster, fun = function(x) {x > 0}, dissolve = TRUE)
habitat_polygons_sf <- st_as_sf(habitat_polygons)
# remove unnecessary variables
rm(habitat_polygons)
rm(patch_raster)
# Calculate the distance matrix between the edges of polygons
dist_matrix <- st_distance(habitat_polygons_sf)
# Check if dist_matrix has units
if (inherits(dist_matrix, "units")) {
dist_matrix <- drop_units(dist_matrix)
} else {
dist_matrix <- dist_matrix
}
install.packages("devtools")
resolution <- 1 # set resolution
x_extent <- 50 # set width
y_extent <- 50 # set height
landscape_config <- 0.4 # level of patch aggregation
ai <- runif(1, min = 0.01, max = 0.45) # proportion of landscape that is habitat
# Generate Landscape ------------------------------------------------------
## Habitat Patches ========================================================
# create neutral landscape with >1 patch
repeat {
# generate landscape using NLMR package
landscape <- nlm_randomcluster(ncol = x_extent, nrow = y_extent,
resolution = resolution,
p = landscape_config,
ai = c((1-ai),ai))
# identify connected patches
clumps <- clump(landscape, directions = 8)
# calculate edge_density
edge_density <- as.numeric(lsm_l_ed(landscape, count_boundary = FALSE, directions = 8)[6])
# coerce to data frame
landscape_df <- rasterToPoints(landscape, spatial = TRUE)
landscape_df <- as.data.frame(landscape_df)
colnames(landscape_df) <- c("layer", "x", "y")
landscape_df$layer <- as.factor(landscape_df$layer)
# add patch numbers to landscape df
coordinates(landscape_df) <- ~x + y
landscape_df$patch <- extract(clumps, landscape_df)
landscape_df <- as.data.frame(landscape_df)
# Check the maximum patch number
max_patch_number <- max(landscape_df$patch, na.rm = TRUE)
# If there is more than one patch, exit the loop
if (max_patch_number > 1) {
break
}
}
# calculate exact landscape cover
landscape_cover <- (sum(landscape_df$layer == 1)/nrow(landscape_df))*100
# remove unecessary variables
rm(clumps)
rm(landscape)
## Calculate Distances and Areas ==========================================
# Calculate distances
# dataframe back to raster
landscape_df_patches <- landscape_df %>%
dplyr::select(x, y, patch)
patch_raster <- rasterFromXYZ(landscape_df_patches)
# remove unnecessary variables
rm(landscape_df_patches)
# set resolution of raster
res(patch_raster) <- c(1, 1)
# set crs of raster
crs(patch_raster) <- CRS("+proj=utm +zone=33 +datum=WGS84")
# Convert raster to polygons
habitat_polygons <- rasterToPolygons(patch_raster, fun = function(x) {x > 0}, dissolve = TRUE)
habitat_polygons_sf <- st_as_sf(habitat_polygons)
# remove unnecessary variables
rm(habitat_polygons)
rm(patch_raster)
# Calculate the distance matrix between the edges of polygons
dist_matrix <- st_distance(habitat_polygons_sf)
# Check if dist_matrix has units
if (inherits(dist_matrix, "units")) {
dist_matrix <- drop_units(dist_matrix)
} else {
dist_matrix <- dist_matrix
}
print(dist_matrix)
area_matrix <- outer(patch_area_df$area, patch_area_df$area, FUN = "*")
source("C:/Users/bs20brkh/OneDrive - University of Leeds/PhD/Topic 1/MPCapacity Model/Trial 1 (20-3-25)/Runs/T1_h_agg_h_disp.R")
rm(list = ls())
# General -----------------------------------------------------------------
install.packages("devtools") # install devtools for packages not on CRAN
library(devtools)
# install packages
install.packages(c("tidyverse", "sf", "units", "ggplot2", "gganimate",
"igraph", "raster", "landscapemetrics", "units"))
# install packages not on CRAN
devtools::install_github("ropensci/NLMR")
install.packages('RandomFields', repos =
'https://predictiveecology.r-universe.dev', type = 'source')
# load packages
library(tidyverse)
library(parallel)
library(NLMR)
library(RandomFields)
library(landscapemetrics)
library(igraph)
library(raster)
library(sf)
library(units)
install.packages(c("tidyverse", "sf", "units", "ggplot2", "gganimate", "igraph", "raster", "landscapemetrics", "units"))
install.packages("devtools")
# Loop for dispersal scenarios --------------------------------------------
# Parameterises model dispersal scenarios
# Define movement responses
# movement can be 'linear', 'convex', or 'concave'
movements <- c('linear', 'concave', 'convex')
